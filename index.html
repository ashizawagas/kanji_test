                // 3. シャープニング
                const kernel = cv.matFromArray(3, 3, cv.CV_32FC1, [0, -1, 0, -1, 5, -1, 0, -1, 0]);
                cv.filter2D(denoised, denoised, cv.CV_8U, kernel);

                // 4. 適応的二値化（複数手法の組み合わせ）
                cv.adaptiveThreshold(denoised, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 15, 2);

                // 5. モルフォロジー演算（ノイズ除去と文字の補強）
                const morphKernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                cv.morphologyEx(binary, morphed, cv.MORPH_CLOSE, morphKernel);
                cv.morphologyEx(morphed, morphed, cv.MORPH_OPEN, morphKernel);

                // 6. 輪郭検出とバウンディングボックス抽出
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();
                cv.findContours(morphed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                if (contours.size() > 0) {
                    // 最大の輪郭を見つける（文字領域と仮定）
                    let maxArea = 0;
                    let maxContourIndex = 0;
                    for (let i = 0; i < contours.size(); i++) {
                        const area = cv.contourArea(contours.get(i));
                        if (area > maxArea && area > 100) { // 最小面積フィルター
                            maxArea = area;
                            maxContourIndex = i;
                        }
                    }

                    if (maxArea > 0) {
                        // バウンディングボックスを取得
                        const rect = cv.boundingRect(contours.get(maxContourIndex));
                        
                        // 余白を追加（文字の完全性を保つため）
                        const padding = 30;
                        const x = Math.max(0, rect.x - padding);
                        const y = Math.max(0, rect.y - padding);
                        const width = Math.min(morphed.cols - x, rect.width + padding * 2);
                        const height = Math.min(morphed.rows - y, rect.height + padding * 2);

                        // ROI（関心領域）を切り出し
                        const roi = new cv.Rect(x, y, width, height);
                        const cropped = morphed.roi(roi);

                        // 正方形にリサイズ（OCR精度向上のため）
                        const maxSize = Math.max(width, height);
                        const squareSize = Math.max(maxSize, 200); // 最小サイズ保証
                        const square = new cv.Mat(squareSize, squareSize, cv.CV_8UC1, new cv.Scalar(255));
                        
                        // 中央配置
                        const offsetX = Math.floor((squareSize - width) / 2);
                        const offsetY = Math.floor((squareSize - height) / 2);
                        
                        cropped.copyTo(square.roi(new cv.Rect(offsetX, offsetY, width, height)));

                        // 最終的に400x400にリサイズ（OCR最適化）
                        cv.resize(square, result, new cv.Size(400, 400), 0, 0, cv.INTER_CUBIC);

                        // 最終的なコントラスト調整
                        const alpha = 1.5; // コントラスト係数
                        const beta = 10;   // 明度調整
                        result.convertTo(result, -1, alpha, beta);

                        // 結果をキャンバスに描画
                        const resultCanvas = document.createElement('canvas');
                        resultCanvas.width = 400;
                        resultCanvas.height = 400;
                        cv.imshow(resultCanvas, result);

                        // メモリ解放
                        src.delete();
                        gray.delete();
                        denoised.delete();
                        binary.delete();
                        morphed.delete();
                        result.delete();
                        contours.delete();
                        hierarchy.delete();
                        cropped.delete();
                        square.delete();
                        kernel.delete();
                        morphKernel.delete();
                        clahe.delete();

                        return resultCanvas;
                    }
                }

                // 輪郭が見つからない場合のフォールバック処理
                cv.resize(morphed, result, new cv.Size(400, 400), 0, 0, cv.INTER_CUBIC);
                
                const resultCanvas = document.createElement('canvas');
                resultCanvas.width = 400;
                resultCanvas.height = 400;
                cv.imshow(resultCanvas, result);

                // メモリ解放
                src.delete();
                gray.delete();
                denoised.delete();
                binary.delete();
                morphed.delete();
                result.delete();
                contours.delete();
                hierarchy.delete();
                kernel.delete();
                morphKernel.delete();
                clahe.delete();

                return resultCanvas;

            } catch (error) {
                console.error('OpenCV超高精度前処理エラー:', error);
                return preprocessCanvasAdvanced(canvas);
            }
        }

        // 高度な画像前処理（OpenCV.js使用）
        function preprocessCanvasAdvanced(canvas) {
            if (!cvReady) {
                return preprocessCanvasBasic(canvas);
            }

            try {
                // OpenCV.jsを使用した高度な前処理
                const src = cv.imread(canvas);
                const gray = new cv.Mat();
                const binary = new cv.Mat();
                const morphed = new cv.Mat();
                const result = new cv.Mat();

                // グレースケール変換
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                // ガウシアンブラーでノイズ除去
                const ksize = new cv.Size(5, 5);
                cv.GaussianBlur(gray, gray, ksize, 0, 0, cv.BORDER_DEFAULT);

                // 適応的二値化
                cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);

                // モルフォロジー演算でノイズ除去
                const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                cv.morphologyEx(binary, morphed, cv.MORPH_CLOSE, kernel);

                // 輪郭検出とバウンディングボックス
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();
                cv.findContours(morphed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                if (contours.size() > 0) {
                    // 最大の輪郭を見つける
                    let maxArea = 0;
                    let maxContourIndex = 0;
                    for (let i = 0; i < contours.size(); i++) {
                        const area = cv.contourArea(contours.get(i));
                        if (area > maxArea) {
                            maxArea = area;
                            maxContourIndex = i;
                        }
                    }

                    // バウンディングボックスを取得
                    const rect = cv.boundingRect(contours.get(maxContourIndex));
                    
                    // 余白を追加
                    const padding = 20;
                    const x = Math.max(0, rect.x - padding);
                    const y = Math.max(0, rect.y - padding);
                    const width = Math.min(morphed.cols - x, rect.width + padding * 2);
                    const height = Math.min(morphed.rows - y, rect.height + padding * 2);

                    // 切り出し
                    const roi = new cv.Rect(x, y, width, height);
                    const cropped = morphed.roi(roi);

                    // 正方形にリサイズ
                    const size = Math.max(width, height);
                    const square = new cv.Mat(size, size, cv.CV_8UC1, new cv.Scalar(255));
                    const offsetX = Math.floor((size - width) / 2);
                    const offsetY = Math.floor((size - height) / 2);
                    
                    cropped.copyTo(square.roi(new cv.Rect(offsetX, offsetY, width, height)));

                    // 最終的に300x300にリサイズ
                    cv.resize(square, result, new cv.Size(300, 300), 0, 0, cv.INTER_CUBIC);

                    // 結果をキャンバスに描画
                    const resultCanvas = document.createElement('canvas');
                    resultCanvas.width = 300;
                    resultCanvas.height = 300;
                    cv.imshow(resultCanvas, result);

                    // メモリ解放
                    src.delete();
                    gray.delete();
                    binary.delete();
                    morphed.delete();
                    result.delete();
                    contours.delete();
                    hierarchy.delete();
                    cropped.delete();
                    square.delete();
                    kernel.delete();

                    return resultCanvas;
                }

                // メモリ解放
                src.delete();
                gray.delete();
                binary.delete();
                morphed.delete();
                result.delete();
                contours.delete();
                hierarchy.delete();
                kernel.delete();

            } catch (error) {
                console.error('OpenCV前処理エラー:', error);
                return preprocessCanvasBasic(canvas);
            }

            return preprocessCanvasBasic(canvas);
        }

        // 基本的な画像前処理
        function preprocessCanvasBasic(canvas) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // 描画領域の検出
            let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    
                    if (r < 250 || g < 250 || b < 250) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            // 余白追加
            const padding = 30;
            minX = Math.max(0, minX - padding);
            maxX = Math.min(canvas.width, maxX + padding);
            minY = Math.max(0, minY - padding);
            maxY = Math.min(canvas.height, maxY + padding);

            // トリミング
            const croppedCanvas = document.createElement('canvas');
            const croppedWidth = maxX - minX;
            const croppedHeight = maxY - minY;
            
            // 正方形にする
            const size = Math.max(croppedWidth, croppedHeight);
            croppedCanvas.width = size;
            croppedCanvas.height = size;
            
            const croppedCtx = croppedCanvas.getContext('2d');
            croppedCtx.fillStyle = '#ffffff';
            croppedCtx.fillRect(0, 0, size, size);
            
            // 中央に配置
            const offsetX = (size - croppedWidth) / 2;
            const offsetY = (size - croppedHeight) / 2;
            
            croppedCtx.drawImage(
                canvas,
                minX, minY, croppedWidth, croppedHeight,
                offsetX, offsetY, croppedWidth, croppedHeight
            );

            // コントラスト強化
            const imageData2 = croppedCtx.getImageData(0, 0, size, size);
            const data2 = imageData2.data;
            
            for (let i = 0; i < data2.length; i += 4) {
                const gray = (data2[i] + data2[i + 1] + data2[i + 2]) / 3;
                const binary = gray > 200 ? 255 : 0;
                data2[i] = data2[i + 1] = data2[i + 2] = binary;
            }
            
            croppedCtx.putImageData(imageData2, 0, 0);

            return croppedCanvas;
        }

        // 類似漢字候補生成
        function generateSimilarKanji(targetKanji) {
            const similarKanjiMap = {
                '学': ['字', '安', '宇', '実'],
                '山': ['川', '出', '岡', '峰'],
                '水': ['氷', '永', '泳', '求'],
                '火': ['灯', '炎', '災', '烈'],
                '土': ['士', '王', '干', '工'],
                '木': ['本', '林', '森', '材'],
                '人': ['入', '八', '大', '天'],
                '大': ['太', '犬', '天', '夫'],
                '小': ['少', '尖', '省', '京'],
                '中': ['内', '申', '由', '甲'],
                '日': ['目', '白', '田', '旧'],
                '月': ['用', '肉', '服', '朋'],
                '年': ['午', '手', '千', '平'],
                '時': ['寺', '持', '待', '詩'],
                '分': ['八', '刀', '力', '公'],
                '秋': ['愁', '私', '和', '科'],
                '朝': ['潮', '廟', '嘲', '韓'],
                '暑': ['者', '諸', '署', '都'],
                '兄': ['況', '克', '光', '党'],
                '姉': ['始', '紙', '指', '脂'],
                '妹': ['未', '味', '魅', '昧'],
                '弟': ['第', '娣', '递', '梯'],
                '親': ['新', '薪', '辛', '近'],
                '子': ['了', '孔', '字', '存'],
                '男': ['力', '田', '思', '界'],
                '女': ['安', '好', '妙', '如'],
                '友': ['有', '右', '存', '反'],
                '仲': ['中', '伸', '沖', '忠'],
                '皆': ['階', '混', '昔', '旨'],
                '自': ['白', '息', '目', '首'],
                '他': ['她', '地', '池', '也']
            };
            
            return similarKanjiMap[targetKanji] || [targetKanji];
        }

        // 答えチェック（高精度OCR対応）
        async function checkAnswer() {
            if (!ocrEngines.tesseract.ready) {
                alert('OCRの準備ができていません。しばらくお待ちください。');
                return;
            }

            if (!hasDrawing()) {
                alert('漢字を書いてください。');
                return;
            }

            if (!currentQuestions || currentQuestions.length === 0) {
                alert('学年を選択してください。');
                return;
            }

            showProcessing(true);
            hideResult();
            hideCandidates();

            try {
                // 超高精度前処理を適用
                const processedCanvas = preprocessCanvasUltraHigh(canvas);
                
                // 複数の認識方法を試行
                const recognitionResults = [];
                
                // Tesseract.js での認識（複数設定）
                const configs = [
                    { psm: Tesseract.PSM.SINGLE_CHAR, oem: Tesseract.OEM.LSTM_ONLY },
                    { psm: Tesseract.PSM.SINGLE_BLOCK, oem: Tesseract.OEM.TESSERACT_LSTM_COMBINED },
                    { psm: Tesseract.PSM.SINGLE_WORD, oem: Tesseract.OEM.DEFAULT }
                ];

                for (const config of configs) {
                    try {
                        const result = await tesseractWorker.recognize(processedCanvas, {
                            tessedit_pageseg_mode: config.psm,
                            tessedit_ocr_engine_mode: config.oem
                        });
                        
                        const cleanedText = result.data.text.trim().replace(/\s+/g, '').replace(/[^\u4e00-\u9faf]/g, '');
                        if (cleanedText && cleanedText.length === 1) {
                            recognitionResults.push({
                                text: cleanedText,
                                confidence: result.data.confidence
                            });
                        }
                    } catch (error) {
                        console.warn('OCR設定エラー:', error);
                    }
                }

                // 結果の統合と候補生成
                const correctAnswer = currentQuestions[currentQuestionIndex].answer;
                let recognizedText = '';
                let isCorrect = false;

                if (recognitionResults.length > 0) {
                    // 最も信頼度の高い結果を選択
                    recognitionResults.sort((a, b) => b.confidence - a.confidence);
                    recognizedText = recognitionResults[0].text;
                    
                    // 正解チェック
                    isCorrect = recognizedText === correctAnswer;
                    
                    if (!isCorrect) {
                        // 類似漢字候補を生成
                        const candidates = generateSimilarKanji(correctAnswer);
                        const allCandidates = [...new Set([recognizedText, correctAnswer, ...candidates])];
                        
                        // 候補が複数ある場合は選択肢を表示
                        if (allCandidates.length > 1) {
                            showCandidates(allCandidates, correctAnswer);
                            return;
                        }
                    }
                } else {
                    // 認識失敗時は候補を表示
                    const candidates = generateSimilarKanji(correctAnswer);
                    showCandidates([correctAnswer, ...candidates], correctAnswer);
                    return;
                }

                // 結果表示
                if (isCorrect) {
                    score++;
                    showResult(true, '正解！', recognizedText);
                } else {
                    showResult(false, `不正解。正解は「${correctAnswer}」です。`, recognizedText || '認識できませんでした');
                }
                
                updateDisplay();
                
            } catch (error) {
                console.error('文字認識エラー:', error);
                showResult(false, '文字認識に失敗しました。文字をもう一度はっきりと書いてください。', '認識エラー');
            } finally {
                showProcessing(false);
            }
        }

        // 候補表示
        function showCandidates(candidates, correctAnswer) {
            elements.candidateButtons.innerHTML = '';
            
            candidates.forEach(candidate => {
                const button = document.createElement('button');
                button.className = 'candidate-btn';
                button.textContent = candidate;
                button.onclick = () => selectCandidate(candidate, correctAnswer);
                elements.candidateButtons.appendChild(button);
            });
            
            elements.candidatesSection.style.display = 'block';
            showProcessing(false);
        }

        // 候補選択
        function selectCandidate(selectedKanji, correctAnswer) {
            hideCandidates();
            
            const isCorrect = selectedKanji === correctAnswer;
            
            if (isCorrect) {
                score++;
                showResult(true, '正解！', selectedKanji);
            } else {
                showResult(false, `不正解。正解は「${correctAnswer}」です。`, selectedKanji);
            }
            
            updateDisplay();
        }

        // 候補非表示
        function hideCandidates() {
            elements.candidatesSection.style.display = 'none';
        }

        // 処理中表示
        function showProcessing(show) {
            elements.processingSection.style.display = show ? 'block' : 'none';
            elements.processingText.textContent = show ? '高精度OCRで文字を認識中...' : '';
            elements.checkBtn.disabled = show;
        }

        // 結果表示
        function showResult(isCorrect, feedback, answer) {
            elements.resultSection.style.display = 'block';
            elements.resultSection.className = `result-section ${isCorrect ? 'result-correct' : 'result-incorrect'}`;
            elements.resultFeedback.textContent = feedback;
            elements.resultAnswer.textContent = `認識結果: ${answer}`;
            
            elements.checkBtn.style.display = 'none';
            elements.nextBtn.style.display = 'inline-flex';
        }

        // 結果非表示
        function hideResult() {
            elements.resultSection.style.display = 'none';
            elements.checkBtn.style.display = 'inline-flex';
            elements.nextBtn.style.display = 'none';
        }

        // 次の問題
        function nextQuestion() {
            if (currentQuestionIndex < currentQuestions.length - 1) {
                currentQuestionIndex++;
                clearCanvas();
                updateDisplay();
            } else {
                showFinalScore();
            }
        }

        // 最終スコア表示
        function showFinalScore() {
            const percentage = Math.round((score / currentQuestions.length) * 100);
            let message = '';
            
            if (percentage >= 80) {
                message = '🎉 素晴らしい！';
            } else if (percentage >= 60) {
                message = '👍 良くできました！';
            } else {
                message = '💪 もう少し頑張りましょう！';
            }
            
            const gradeText = currentGrade === 0 ? '全学年' : `${currentGrade}年生`;
            
            const finalScoreDiv = document.createElement('div');
            finalScoreDiv.className = 'final-score';
            finalScoreDiv.innerHTML = `
                <h3>${message}</h3>
                <div style="font-size: 1.5em; margin: 15px 0;">
                    ${gradeText}の漢字テスト<br>
                    最終スコア: ${score}/${currentQuestions.length} (${percentage}%)
                </div>
                <button class="btn btn-next" onclick="resetTest()">
                    🔄 もう一度挑戦
                </button>
                <button class="btn btn-grade" onclick="backToGradeSelection()">
                    📚 学年選択に戻る
                </button>
            `;
            
            elements.resultSection.replaceWith(finalScoreDiv);
            elements.nextBtn.style.display = 'none';
        }

        // テストリセット
        function resetTest() {
            currentQuestionIndex = 0;
            score = 0;
            
            if (currentGrade === 0) {
                const allQuestions = Object.values(kanjiQuestions).flat();
                currentQuestions = shuffleArray(allQuestions).slice(0, 20);
            } else {
                currentQuestions = shuffleArray([...kanjiQuestions[currentGrade]]).slice(0, 10);
            }
            
            clearCanvas();
            updateDisplay();
            
            // 最終スコア表示を削除
            const finalScore = document.querySelector('.final-score');
            if (finalScore) {
                finalScore.replaceWith(elements.resultSection);
            }
            
            hideResult();
            hideCandidates();
        }

        // 表示更新
        function updateDisplay() {
            if (!currentQuestions || currentQuestions.length === 0) return;
            
            const currentQ = currentQuestions[currentQuestionIndex];
            
            elements.currentQuestion.textContent = currentQuestionIndex + 1;
            elements.totalQuestions.textContent = currentQuestions.length;
            elements.currentScore.textContent = score;
            elements.questionText.innerHTML = currentQ.text;
            elements.questionHint.textContent = currentQ.hint;
            
            if (currentGrade === 0) {
                elements.gradeInfo.textContent = '小学校全学年の漢字';
            } else {
                elements.gradeInfo.textContent = `小学校${currentGrade}年生の漢字`;
            }
        }
    </script>
</body>
</html>
