                // 3. ã‚·ãƒ£ãƒ¼ãƒ—ãƒ‹ãƒ³ã‚°
                const kernel = cv.matFromArray(3, 3, cv.CV_32FC1, [0, -1, 0, -1, 5, -1, 0, -1, 0]);
                cv.filter2D(denoised, denoised, cv.CV_8U, kernel);

                // 4. é©å¿œçš„äºŒå€¤åŒ–ï¼ˆè¤‡æ•°æ‰‹æ³•ã®çµ„ã¿åˆã‚ã›ï¼‰
                cv.adaptiveThreshold(denoised, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 15, 2);

                // 5. ãƒ¢ãƒ«ãƒ•ã‚©ãƒ­ã‚¸ãƒ¼æ¼”ç®—ï¼ˆãƒã‚¤ã‚ºé™¤å»ã¨æ–‡å­—ã®è£œå¼·ï¼‰
                const morphKernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                cv.morphologyEx(binary, morphed, cv.MORPH_CLOSE, morphKernel);
                cv.morphologyEx(morphed, morphed, cv.MORPH_OPEN, morphKernel);

                // 6. è¼ªéƒ­æ¤œå‡ºã¨ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹æŠ½å‡º
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();
                cv.findContours(morphed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                if (contours.size() > 0) {
                    // æœ€å¤§ã®è¼ªéƒ­ã‚’è¦‹ã¤ã‘ã‚‹ï¼ˆæ–‡å­—é ˜åŸŸã¨ä»®å®šï¼‰
                    let maxArea = 0;
                    let maxContourIndex = 0;
                    for (let i = 0; i < contours.size(); i++) {
                        const area = cv.contourArea(contours.get(i));
                        if (area > maxArea && area > 100) { // æœ€å°é¢ç©ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
                            maxArea = area;
                            maxContourIndex = i;
                        }
                    }

                    if (maxArea > 0) {
                        // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’å–å¾—
                        const rect = cv.boundingRect(contours.get(maxContourIndex));
                        
                        // ä½™ç™½ã‚’è¿½åŠ ï¼ˆæ–‡å­—ã®å®Œå…¨æ€§ã‚’ä¿ã¤ãŸã‚ï¼‰
                        const padding = 30;
                        const x = Math.max(0, rect.x - padding);
                        const y = Math.max(0, rect.y - padding);
                        const width = Math.min(morphed.cols - x, rect.width + padding * 2);
                        const height = Math.min(morphed.rows - y, rect.height + padding * 2);

                        // ROIï¼ˆé–¢å¿ƒé ˜åŸŸï¼‰ã‚’åˆ‡ã‚Šå‡ºã—
                        const roi = new cv.Rect(x, y, width, height);
                        const cropped = morphed.roi(roi);

                        // æ­£æ–¹å½¢ã«ãƒªã‚µã‚¤ã‚ºï¼ˆOCRç²¾åº¦å‘ä¸Šã®ãŸã‚ï¼‰
                        const maxSize = Math.max(width, height);
                        const squareSize = Math.max(maxSize, 200); // æœ€å°ã‚µã‚¤ã‚ºä¿è¨¼
                        const square = new cv.Mat(squareSize, squareSize, cv.CV_8UC1, new cv.Scalar(255));
                        
                        // ä¸­å¤®é…ç½®
                        const offsetX = Math.floor((squareSize - width) / 2);
                        const offsetY = Math.floor((squareSize - height) / 2);
                        
                        cropped.copyTo(square.roi(new cv.Rect(offsetX, offsetY, width, height)));

                        // æœ€çµ‚çš„ã«400x400ã«ãƒªã‚µã‚¤ã‚ºï¼ˆOCRæœ€é©åŒ–ï¼‰
                        cv.resize(square, result, new cv.Size(400, 400), 0, 0, cv.INTER_CUBIC);

                        // æœ€çµ‚çš„ãªã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆèª¿æ•´
                        const alpha = 1.5; // ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆä¿‚æ•°
                        const beta = 10;   // æ˜åº¦èª¿æ•´
                        result.convertTo(result, -1, alpha, beta);

                        // çµæœã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹ã«æç”»
                        const resultCanvas = document.createElement('canvas');
                        resultCanvas.width = 400;
                        resultCanvas.height = 400;
                        cv.imshow(resultCanvas, result);

                        // ãƒ¡ãƒ¢ãƒªè§£æ”¾
                        src.delete();
                        gray.delete();
                        denoised.delete();
                        binary.delete();
                        morphed.delete();
                        result.delete();
                        contours.delete();
                        hierarchy.delete();
                        cropped.delete();
                        square.delete();
                        kernel.delete();
                        morphKernel.delete();
                        clahe.delete();

                        return resultCanvas;
                    }
                }

                // è¼ªéƒ­ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
                cv.resize(morphed, result, new cv.Size(400, 400), 0, 0, cv.INTER_CUBIC);
                
                const resultCanvas = document.createElement('canvas');
                resultCanvas.width = 400;
                resultCanvas.height = 400;
                cv.imshow(resultCanvas, result);

                // ãƒ¡ãƒ¢ãƒªè§£æ”¾
                src.delete();
                gray.delete();
                denoised.delete();
                binary.delete();
                morphed.delete();
                result.delete();
                contours.delete();
                hierarchy.delete();
                kernel.delete();
                morphKernel.delete();
                clahe.delete();

                return resultCanvas;

            } catch (error) {
                console.error('OpenCVè¶…é«˜ç²¾åº¦å‰å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                return preprocessCanvasAdvanced(canvas);
            }
        }

        // é«˜åº¦ãªç”»åƒå‰å‡¦ç†ï¼ˆOpenCV.jsä½¿ç”¨ï¼‰
        function preprocessCanvasAdvanced(canvas) {
            if (!cvReady) {
                return preprocessCanvasBasic(canvas);
            }

            try {
                // OpenCV.jsã‚’ä½¿ç”¨ã—ãŸé«˜åº¦ãªå‰å‡¦ç†
                const src = cv.imread(canvas);
                const gray = new cv.Mat();
                const binary = new cv.Mat();
                const morphed = new cv.Mat();
                const result = new cv.Mat();

                // ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                // ã‚¬ã‚¦ã‚·ã‚¢ãƒ³ãƒ–ãƒ©ãƒ¼ã§ãƒã‚¤ã‚ºé™¤å»
                const ksize = new cv.Size(5, 5);
                cv.GaussianBlur(gray, gray, ksize, 0, 0, cv.BORDER_DEFAULT);

                // é©å¿œçš„äºŒå€¤åŒ–
                cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);

                // ãƒ¢ãƒ«ãƒ•ã‚©ãƒ­ã‚¸ãƒ¼æ¼”ç®—ã§ãƒã‚¤ã‚ºé™¤å»
                const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                cv.morphologyEx(binary, morphed, cv.MORPH_CLOSE, kernel);

                // è¼ªéƒ­æ¤œå‡ºã¨ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();
                cv.findContours(morphed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                if (contours.size() > 0) {
                    // æœ€å¤§ã®è¼ªéƒ­ã‚’è¦‹ã¤ã‘ã‚‹
                    let maxArea = 0;
                    let maxContourIndex = 0;
                    for (let i = 0; i < contours.size(); i++) {
                        const area = cv.contourArea(contours.get(i));
                        if (area > maxArea) {
                            maxArea = area;
                            maxContourIndex = i;
                        }
                    }

                    // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’å–å¾—
                    const rect = cv.boundingRect(contours.get(maxContourIndex));
                    
                    // ä½™ç™½ã‚’è¿½åŠ 
                    const padding = 20;
                    const x = Math.max(0, rect.x - padding);
                    const y = Math.max(0, rect.y - padding);
                    const width = Math.min(morphed.cols - x, rect.width + padding * 2);
                    const height = Math.min(morphed.rows - y, rect.height + padding * 2);

                    // åˆ‡ã‚Šå‡ºã—
                    const roi = new cv.Rect(x, y, width, height);
                    const cropped = morphed.roi(roi);

                    // æ­£æ–¹å½¢ã«ãƒªã‚µã‚¤ã‚º
                    const size = Math.max(width, height);
                    const square = new cv.Mat(size, size, cv.CV_8UC1, new cv.Scalar(255));
                    const offsetX = Math.floor((size - width) / 2);
                    const offsetY = Math.floor((size - height) / 2);
                    
                    cropped.copyTo(square.roi(new cv.Rect(offsetX, offsetY, width, height)));

                    // æœ€çµ‚çš„ã«300x300ã«ãƒªã‚µã‚¤ã‚º
                    cv.resize(square, result, new cv.Size(300, 300), 0, 0, cv.INTER_CUBIC);

                    // çµæœã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹ã«æç”»
                    const resultCanvas = document.createElement('canvas');
                    resultCanvas.width = 300;
                    resultCanvas.height = 300;
                    cv.imshow(resultCanvas, result);

                    // ãƒ¡ãƒ¢ãƒªè§£æ”¾
                    src.delete();
                    gray.delete();
                    binary.delete();
                    morphed.delete();
                    result.delete();
                    contours.delete();
                    hierarchy.delete();
                    cropped.delete();
                    square.delete();
                    kernel.delete();

                    return resultCanvas;
                }

                // ãƒ¡ãƒ¢ãƒªè§£æ”¾
                src.delete();
                gray.delete();
                binary.delete();
                morphed.delete();
                result.delete();
                contours.delete();
                hierarchy.delete();
                kernel.delete();

            } catch (error) {
                console.error('OpenCVå‰å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                return preprocessCanvasBasic(canvas);
            }

            return preprocessCanvasBasic(canvas);
        }

        // åŸºæœ¬çš„ãªç”»åƒå‰å‡¦ç†
        function preprocessCanvasBasic(canvas) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // æç”»é ˜åŸŸã®æ¤œå‡º
            let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    
                    if (r < 250 || g < 250 || b < 250) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            // ä½™ç™½è¿½åŠ 
            const padding = 30;
            minX = Math.max(0, minX - padding);
            maxX = Math.min(canvas.width, maxX + padding);
            minY = Math.max(0, minY - padding);
            maxY = Math.min(canvas.height, maxY + padding);

            // ãƒˆãƒªãƒŸãƒ³ã‚°
            const croppedCanvas = document.createElement('canvas');
            const croppedWidth = maxX - minX;
            const croppedHeight = maxY - minY;
            
            // æ­£æ–¹å½¢ã«ã™ã‚‹
            const size = Math.max(croppedWidth, croppedHeight);
            croppedCanvas.width = size;
            croppedCanvas.height = size;
            
            const croppedCtx = croppedCanvas.getContext('2d');
            croppedCtx.fillStyle = '#ffffff';
            croppedCtx.fillRect(0, 0, size, size);
            
            // ä¸­å¤®ã«é…ç½®
            const offsetX = (size - croppedWidth) / 2;
            const offsetY = (size - croppedHeight) / 2;
            
            croppedCtx.drawImage(
                canvas,
                minX, minY, croppedWidth, croppedHeight,
                offsetX, offsetY, croppedWidth, croppedHeight
            );

            // ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆå¼·åŒ–
            const imageData2 = croppedCtx.getImageData(0, 0, size, size);
            const data2 = imageData2.data;
            
            for (let i = 0; i < data2.length; i += 4) {
                const gray = (data2[i] + data2[i + 1] + data2[i + 2]) / 3;
                const binary = gray > 200 ? 255 : 0;
                data2[i] = data2[i + 1] = data2[i + 2] = binary;
            }
            
            croppedCtx.putImageData(imageData2, 0, 0);

            return croppedCanvas;
        }

        // é¡ä¼¼æ¼¢å­—å€™è£œç”Ÿæˆ
        function generateSimilarKanji(targetKanji) {
            const similarKanjiMap = {
                'å­¦': ['å­—', 'å®‰', 'å®‡', 'å®Ÿ'],
                'å±±': ['å·', 'å‡º', 'å²¡', 'å³°'],
                'æ°´': ['æ°·', 'æ°¸', 'æ³³', 'æ±‚'],
                'ç«': ['ç¯', 'ç‚', 'ç½', 'çƒˆ'],
                'åœŸ': ['å£«', 'ç‹', 'å¹²', 'å·¥'],
                'æœ¨': ['æœ¬', 'æ—', 'æ£®', 'æ'],
                'äºº': ['å…¥', 'å…«', 'å¤§', 'å¤©'],
                'å¤§': ['å¤ª', 'çŠ¬', 'å¤©', 'å¤«'],
                'å°': ['å°‘', 'å°–', 'çœ', 'äº¬'],
                'ä¸­': ['å†…', 'ç”³', 'ç”±', 'ç”²'],
                'æ—¥': ['ç›®', 'ç™½', 'ç”°', 'æ—§'],
                'æœˆ': ['ç”¨', 'è‚‰', 'æœ', 'æœ‹'],
                'å¹´': ['åˆ', 'æ‰‹', 'åƒ', 'å¹³'],
                'æ™‚': ['å¯º', 'æŒ', 'å¾…', 'è©©'],
                'åˆ†': ['å…«', 'åˆ€', 'åŠ›', 'å…¬'],
                'ç§‹': ['æ„', 'ç§', 'å’Œ', 'ç§‘'],
                'æœ': ['æ½®', 'å»Ÿ', 'å˜²', 'éŸ“'],
                'æš‘': ['è€…', 'è«¸', 'ç½²', 'éƒ½'],
                'å…„': ['æ³', 'å…‹', 'å…‰', 'å…š'],
                'å§‰': ['å§‹', 'ç´™', 'æŒ‡', 'è„‚'],
                'å¦¹': ['æœª', 'å‘³', 'é­…', 'æ˜§'],
                'å¼Ÿ': ['ç¬¬', 'å¨£', 'é€’', 'æ¢¯'],
                'è¦ª': ['æ–°', 'è–ª', 'è¾›', 'è¿‘'],
                'å­': ['äº†', 'å­”', 'å­—', 'å­˜'],
                'ç”·': ['åŠ›', 'ç”°', 'æ€', 'ç•Œ'],
                'å¥³': ['å®‰', 'å¥½', 'å¦™', 'å¦‚'],
                'å‹': ['æœ‰', 'å³', 'å­˜', 'å'],
                'ä»²': ['ä¸­', 'ä¼¸', 'æ²–', 'å¿ '],
                'çš†': ['éš', 'æ··', 'æ˜”', 'æ—¨'],
                'è‡ª': ['ç™½', 'æ¯', 'ç›®', 'é¦–'],
                'ä»–': ['å¥¹', 'åœ°', 'æ± ', 'ä¹Ÿ']
            };
            
            return similarKanjiMap[targetKanji] || [targetKanji];
        }

        // ç­”ãˆãƒã‚§ãƒƒã‚¯ï¼ˆé«˜ç²¾åº¦OCRå¯¾å¿œï¼‰
        async function checkAnswer() {
            if (!ocrEngines.tesseract.ready) {
                alert('OCRã®æº–å‚™ãŒã§ãã¦ã„ã¾ã›ã‚“ã€‚ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚');
                return;
            }

            if (!hasDrawing()) {
                alert('æ¼¢å­—ã‚’æ›¸ã„ã¦ãã ã•ã„ã€‚');
                return;
            }

            if (!currentQuestions || currentQuestions.length === 0) {
                alert('å­¦å¹´ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                return;
            }

            showProcessing(true);
            hideResult();
            hideCandidates();

            try {
                // è¶…é«˜ç²¾åº¦å‰å‡¦ç†ã‚’é©ç”¨
                const processedCanvas = preprocessCanvasUltraHigh(canvas);
                
                // è¤‡æ•°ã®èªè­˜æ–¹æ³•ã‚’è©¦è¡Œ
                const recognitionResults = [];
                
                // Tesseract.js ã§ã®èªè­˜ï¼ˆè¤‡æ•°è¨­å®šï¼‰
                const configs = [
                    { psm: Tesseract.PSM.SINGLE_CHAR, oem: Tesseract.OEM.LSTM_ONLY },
                    { psm: Tesseract.PSM.SINGLE_BLOCK, oem: Tesseract.OEM.TESSERACT_LSTM_COMBINED },
                    { psm: Tesseract.PSM.SINGLE_WORD, oem: Tesseract.OEM.DEFAULT }
                ];

                for (const config of configs) {
                    try {
                        const result = await tesseractWorker.recognize(processedCanvas, {
                            tessedit_pageseg_mode: config.psm,
                            tessedit_ocr_engine_mode: config.oem
                        });
                        
                        const cleanedText = result.data.text.trim().replace(/\s+/g, '').replace(/[^\u4e00-\u9faf]/g, '');
                        if (cleanedText && cleanedText.length === 1) {
                            recognitionResults.push({
                                text: cleanedText,
                                confidence: result.data.confidence
                            });
                        }
                    } catch (error) {
                        console.warn('OCRè¨­å®šã‚¨ãƒ©ãƒ¼:', error);
                    }
                }

                // çµæœã®çµ±åˆã¨å€™è£œç”Ÿæˆ
                const correctAnswer = currentQuestions[currentQuestionIndex].answer;
                let recognizedText = '';
                let isCorrect = false;

                if (recognitionResults.length > 0) {
                    // æœ€ã‚‚ä¿¡é ¼åº¦ã®é«˜ã„çµæœã‚’é¸æŠ
                    recognitionResults.sort((a, b) => b.confidence - a.confidence);
                    recognizedText = recognitionResults[0].text;
                    
                    // æ­£è§£ãƒã‚§ãƒƒã‚¯
                    isCorrect = recognizedText === correctAnswer;
                    
                    if (!isCorrect) {
                        // é¡ä¼¼æ¼¢å­—å€™è£œã‚’ç”Ÿæˆ
                        const candidates = generateSimilarKanji(correctAnswer);
                        const allCandidates = [...new Set([recognizedText, correctAnswer, ...candidates])];
                        
                        // å€™è£œãŒè¤‡æ•°ã‚ã‚‹å ´åˆã¯é¸æŠè‚¢ã‚’è¡¨ç¤º
                        if (allCandidates.length > 1) {
                            showCandidates(allCandidates, correctAnswer);
                            return;
                        }
                    }
                } else {
                    // èªè­˜å¤±æ•—æ™‚ã¯å€™è£œã‚’è¡¨ç¤º
                    const candidates = generateSimilarKanji(correctAnswer);
                    showCandidates([correctAnswer, ...candidates], correctAnswer);
                    return;
                }

                // çµæœè¡¨ç¤º
                if (isCorrect) {
                    score++;
                    showResult(true, 'æ­£è§£ï¼', recognizedText);
                } else {
                    showResult(false, `ä¸æ­£è§£ã€‚æ­£è§£ã¯ã€Œ${correctAnswer}ã€ã§ã™ã€‚`, recognizedText || 'èªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸ');
                }
                
                updateDisplay();
                
            } catch (error) {
                console.error('æ–‡å­—èªè­˜ã‚¨ãƒ©ãƒ¼:', error);
                showResult(false, 'æ–‡å­—èªè­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ–‡å­—ã‚’ã‚‚ã†ä¸€åº¦ã¯ã£ãã‚Šã¨æ›¸ã„ã¦ãã ã•ã„ã€‚', 'èªè­˜ã‚¨ãƒ©ãƒ¼');
            } finally {
                showProcessing(false);
            }
        }

        // å€™è£œè¡¨ç¤º
        function showCandidates(candidates, correctAnswer) {
            elements.candidateButtons.innerHTML = '';
            
            candidates.forEach(candidate => {
                const button = document.createElement('button');
                button.className = 'candidate-btn';
                button.textContent = candidate;
                button.onclick = () => selectCandidate(candidate, correctAnswer);
                elements.candidateButtons.appendChild(button);
            });
            
            elements.candidatesSection.style.display = 'block';
            showProcessing(false);
        }

        // å€™è£œé¸æŠ
        function selectCandidate(selectedKanji, correctAnswer) {
            hideCandidates();
            
            const isCorrect = selectedKanji === correctAnswer;
            
            if (isCorrect) {
                score++;
                showResult(true, 'æ­£è§£ï¼', selectedKanji);
            } else {
                showResult(false, `ä¸æ­£è§£ã€‚æ­£è§£ã¯ã€Œ${correctAnswer}ã€ã§ã™ã€‚`, selectedKanji);
            }
            
            updateDisplay();
        }

        // å€™è£œéè¡¨ç¤º
        function hideCandidates() {
            elements.candidatesSection.style.display = 'none';
        }

        // å‡¦ç†ä¸­è¡¨ç¤º
        function showProcessing(show) {
            elements.processingSection.style.display = show ? 'block' : 'none';
            elements.processingText.textContent = show ? 'é«˜ç²¾åº¦OCRã§æ–‡å­—ã‚’èªè­˜ä¸­...' : '';
            elements.checkBtn.disabled = show;
        }

        // çµæœè¡¨ç¤º
        function showResult(isCorrect, feedback, answer) {
            elements.resultSection.style.display = 'block';
            elements.resultSection.className = `result-section ${isCorrect ? 'result-correct' : 'result-incorrect'}`;
            elements.resultFeedback.textContent = feedback;
            elements.resultAnswer.textContent = `èªè­˜çµæœ: ${answer}`;
            
            elements.checkBtn.style.display = 'none';
            elements.nextBtn.style.display = 'inline-flex';
        }

        // çµæœéè¡¨ç¤º
        function hideResult() {
            elements.resultSection.style.display = 'none';
            elements.checkBtn.style.display = 'inline-flex';
            elements.nextBtn.style.display = 'none';
        }

        // æ¬¡ã®å•é¡Œ
        function nextQuestion() {
            if (currentQuestionIndex < currentQuestions.length - 1) {
                currentQuestionIndex++;
                clearCanvas();
                updateDisplay();
            } else {
                showFinalScore();
            }
        }

        // æœ€çµ‚ã‚¹ã‚³ã‚¢è¡¨ç¤º
        function showFinalScore() {
            const percentage = Math.round((score / currentQuestions.length) * 100);
            let message = '';
            
            if (percentage >= 80) {
                message = 'ğŸ‰ ç´ æ™´ã‚‰ã—ã„ï¼';
            } else if (percentage >= 60) {
                message = 'ğŸ‘ è‰¯ãã§ãã¾ã—ãŸï¼';
            } else {
                message = 'ğŸ’ª ã‚‚ã†å°‘ã—é ‘å¼µã‚Šã¾ã—ã‚‡ã†ï¼';
            }
            
            const gradeText = currentGrade === 0 ? 'å…¨å­¦å¹´' : `${currentGrade}å¹´ç”Ÿ`;
            
            const finalScoreDiv = document.createElement('div');
            finalScoreDiv.className = 'final-score';
            finalScoreDiv.innerHTML = `
                <h3>${message}</h3>
                <div style="font-size: 1.5em; margin: 15px 0;">
                    ${gradeText}ã®æ¼¢å­—ãƒ†ã‚¹ãƒˆ<br>
                    æœ€çµ‚ã‚¹ã‚³ã‚¢: ${score}/${currentQuestions.length} (${percentage}%)
                </div>
                <button class="btn btn-next" onclick="resetTest()">
                    ğŸ”„ ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦
                </button>
                <button class="btn btn-grade" onclick="backToGradeSelection()">
                    ğŸ“š å­¦å¹´é¸æŠã«æˆ»ã‚‹
                </button>
            `;
            
            elements.resultSection.replaceWith(finalScoreDiv);
            elements.nextBtn.style.display = 'none';
        }

        // ãƒ†ã‚¹ãƒˆãƒªã‚»ãƒƒãƒˆ
        function resetTest() {
            currentQuestionIndex = 0;
            score = 0;
            
            if (currentGrade === 0) {
                const allQuestions = Object.values(kanjiQuestions).flat();
                currentQuestions = shuffleArray(allQuestions).slice(0, 20);
            } else {
                currentQuestions = shuffleArray([...kanjiQuestions[currentGrade]]).slice(0, 10);
            }
            
            clearCanvas();
            updateDisplay();
            
            // æœ€çµ‚ã‚¹ã‚³ã‚¢è¡¨ç¤ºã‚’å‰Šé™¤
            const finalScore = document.querySelector('.final-score');
            if (finalScore) {
                finalScore.replaceWith(elements.resultSection);
            }
            
            hideResult();
            hideCandidates();
        }

        // è¡¨ç¤ºæ›´æ–°
        function updateDisplay() {
            if (!currentQuestions || currentQuestions.length === 0) return;
            
            const currentQ = currentQuestions[currentQuestionIndex];
            
            elements.currentQuestion.textContent = currentQuestionIndex + 1;
            elements.totalQuestions.textContent = currentQuestions.length;
            elements.currentScore.textContent = score;
            elements.questionText.innerHTML = currentQ.text;
            elements.questionHint.textContent = currentQ.hint;
            
            if (currentGrade === 0) {
                elements.gradeInfo.textContent = 'å°å­¦æ ¡å…¨å­¦å¹´ã®æ¼¢å­—';
            } else {
                elements.gradeInfo.textContent = `å°å­¦æ ¡${currentGrade}å¹´ç”Ÿã®æ¼¢å­—`;
            }
        }
    </script>
</body>
</html>
